/*	Notes:
 * In trekking.h
 * 		bool colors[3];
 *		////bool readColors();
 *		bool begin_retreat;
 * 		Position dodge[3];
 *		int current_dodge;
 *
 * In Trekking::reset()
 *		////begin_retreat=true;
 *
 * Conferir se useremos 2 ou 3 sensores
 */


void Trekking::refinedSearch(float dT) {
	// data
	readSonars();

	float refLinear = MAX_LINEAR_VELOCITY/2;
	float minFactor = 0.25*MAX_LINEAR_VELOCITY;
	float refAngular = MAX_ANGULAR_VELOCITY/2;
	float matrixW[] = {1, 0, -1};
	float dodgeDistance = 40;

	// processing
	if (sonars[1]<=MIN_SONAR_DISTANCE){
		if (!readColors()){
			obstacles.add(current_position);
			operation_mode = &Trekking::desvio;
			current_dodge = 0;

			float angle = current_position.getTheta();
			Position a(current_position.getX()-dodgeDistance*cos(angle),current_position.getY()-dodgeDistance*sin(angle),-angle);
			Position b(a.getX()+dodgeDistance*cos(angle-PI/3),a.getY()+dodgeDistance*sin(angle-PI/3),angle-PI/3);
			Position c(b.getX()+dodgeDistance*cos(angle),b.getY()+dodgeDistance*sin(angle),angle);

			dodge[0] = a;
			dodge[1] = b;
			dodge[2] = c;
		}
		else{
			operation_mode = &Trekking::lighting;
			controlMotors(0,0,false,0);
		}
	}
	else if (sonars[0]>MAX_SONAR_DISTANCE && sonars[1]>MAX_SONAR_DISTANCE && sonars[2]>MAX_SONAR_DISTANCE){
		controlMotors(0,refAngular,false,0);
	}
	else{
		float w,v = 0;
		for (int i=0;i<3;i++){
			if (sonars[i]>MAX_SONAR_DISTANCE){sonars[i]=0;}
			w += sonars[i]*matrixW[i];
		}
		w = (w*refAngular)/MAX_SONAR_DISTANCE;
		if (sonars[1]==0) v = 0;
		else v = max((refLinear)/(MAX_SONAR_DISTANCE-MIN_SONAR_DISTANCE)*(sonars[1]),minFactor);
//		v = refLinear*(exp(/*k*/-1.5*MAX_SONAR_DISTANCE/v)+minFactor);
		controlMotors(v,w,false,0);
	}
}

bool Trekking::readColors(){
	/*
	 * AINDA ESTÁ EM PSEUDO-CÓDIGO
	 */
	bool white[3];
	white[0] = left_color.isWhite();
	white[1] = center_color.isWhite();
	white[2] = right_color.isWhite();
	int count = 0;
	for (i=0;i<3;i++){
		if (white[i]==true) count++;
		if (count>1) return true;
	}
	return false;
}

void Trekking::desvio(){	// TEM QUE SER DECLARADA!!
	//  references
	float v = MAX_LINEAR_VELOCITY/2;
	float w = MAX_ANGULAR_VELOCITY/2;

	{/* colocar rotina de seguir os pontos de desvio */}

	if (current_position==dodge[current_dodge]){
		current_dodge = current_dodge + 1;

		regulateControl(q_desired, dT);
	}
	if (current_dodge==3){
			operation_mode = &Trekking::refinedSearch;
	}
}
