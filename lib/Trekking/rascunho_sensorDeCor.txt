/*	Notes:
 * In trekking.h
 * 		bool colors[3];
 *		bool readColors();
 *		bool begin_retreat;
 * In Trekking::reset()
 *		begin_retreat=true;
 *
 *
 * Add pins and information about the color sensors
 */


void Trekking::refinedSearch(float dT) {
	// data
	readSonars();

	float refLinear = MAX_LINEAR_VELOCITY/2;
	float minFactor = 0.25*MAX_LINEAR_VELOCITY;
	float refAngular = MAX_ANGULAR_VELOCITY/2;
	float matrixW[] = {1, 0, -1};

	// processing
	if (sonars[1]<=MIN_SONAR_DISTANCE){
		if (!readColors()){
			obstacles.add(current_position);
			operation_mode = &Trekking::desvio;
		}
		else{
			operation_mode = &Trekking::lighting;
			controlMotors(0,0,false,0);
		}
	}
	else if (sonars[0]>MAX_SONAR_DISTANCE && sonars[1]>MAX_SONAR_DISTANCE && sonars[2]>MAX_SONAR_DISTANCE){
		controlMotors(0,refAngular,false,0);
	}
	else{
		float w,v = 0;
		for (int i=0;i<3;i++){
			if (sonars[i]>MAX_SONAR_DISTANCE){sonars[i]=0;}
			w += sonars[i]*matrixW[i];
		}
		w = (w*refAngular)/MAX_SONAR_DISTANCE;
		if (sonars[1]==0) v = 0;
		else v = max((refLinear)/(MAX_SONAR_DISTANCE-MIN_SONAR_DISTANCE)*(sonars[1]),minFactor);
//		v = refLinear*(exp(/*k*/-1.5*MAX_SONAR_DISTANCE/v)+minFactor);
		controlMotors(v,w,false,0);
	}
}

bool Trekking::readColors(){
	/*
	 * AINDA ESTÁ EM PSEUDO-CÓDIGO
	 */
	colors[0] = color0.isWhite();
	colors[1] = color1.isWhite();
	colors[2] = color2.isWhite();
	int count = 0;
	for (i=0;i<3;i++){
		if (colors[i]==true) count++;
		if (count>1) return true;
	}
	return false;
}

void Trekking::desvio(){	// TEM QUE SER DECLARADA!!
	/*
	 * Rotina de desvio
	 *	ideia: andar para trás girando por alguns segundos, ir para frente e
	 * contornar o obstáculo
	 */
	//  data
	readSonars();

	//  references
	float v = MAX_LINEAR_VELOCITY/2;
	float w = MAX_ANGULAR_VELOCITY/2;

	if(begin_retreat==true){
		int side = 1;
		if (sonars[0]<sonars[2]) side = -1;
		controlMotors(-v,side*w,false);
		begin_retreat=false;
	}
  delay(5000);    // Check time needed!!!

	/*
	 * Até agora teoricamente já temos o obstáculo fora de nosso campo de visão.
	 * Como contorná-lo sem voltar a bater nele? Como consideramos que já
	 * podemos voltar para a refinedSearch?
	 */

	operation_mode = &Trekking::refinedSearch;
}
